\section{Test}
\myworries{Vi skal bruge et eller flere brugsmønstre (som fungerer som krav) og ud fra det skrive om hvordan vi har testet funktionaliteten af løsningen på kravet - kechr}

\subsection{1. Iteration af desktop-klient testning}
\subsubsection{Test af Views enum}
En af de test der bliver udført i core pakken er ViewsTest. Testen har ikke brug for nogen forberedelse da den kun skal checke om de værdier der er i Views (et enum) er en af dens værdier. Det gør den ved først at iterere igennem alle Views' værdier og for hver værdi kalder metoden isView.\\

\begin{code}[caption=ViewsTest.java, firstnumber=10]
@Test
public void testEnumValues() {
    for (Views view : Views.values()) {
        assertTrue(isView(view));
    }
}
\end{code}

Denne metoder tager et view og tjekker alle Views' værdier og tjekker hvis værdien er lig den indsatte værdi. Hvis den findes returnere den true eller false.

\begin{code}[caption=ViewsTest.java, firstnumber=17]
public boolean isView(Views view) {
    for (Views vie : Views.values()) {
        if (vie.equals(view)) {
            return true;
        }
    }
    return false;
}
\end{code}

\subsubsection{Test af endpoint klassen}
\begin{code}[caption=UsersEndpointTest.java, firstnumber=8]
UsersEndpoint usersEndpoint;

public UsersEndpointTest() {
    usersEndpoint = new UsersEndpoint(new HttpManager());
}
\end{code}\\

UserEndpoint testen starter ved at den i dens constructer danner et nyt userEndpoint objekt. \\
postLogin testen tester om en der kan logges ind i systemet. Det gør den ved at hente den token man får tilbage når man logger ind. Det token er en string der er null hvis brugeren ikke kunne logge ind eller en lang string som giver brugen adgang til applikationen i sat stykke tid. \\
    

\begin{code}[caption=UsersEndpointTest.java, firstnumber=34]
@Test
void postLogin() {
    var token = usersEndpoint.postLogin("string@string.dk", "string");
    assertNotEquals(null, token);
    token = usersEndpoint.postLogin("wronglogin@string.dk", "string");
    assertNull(token);
}
\end{code}    

Efter at have dannet token objektet tjekker den om at den ikke er null. Det gør den ved at bruge assertNotEquals metoden der tjekker om den værdi man giver den ikke er den forventede værdi. Så hvis token objektet ikker null består testen. \\

Herefter bliver der testet for det modsatte. Der bliver igen oprettet et token objekt med et forkert login så token objektet skulle gerne være null. Efter objektet er oprettet bliver det testet af assertNull der tester om værdien er null. Så hvis værdien er null består testen. \\

\subsubsection{Test af loginViewModel}
Testen af loginViewModel sker ved at der i constructeren bliver oprettet en loginViewModel\\
\begin{code}[caption=LoginViewModel.java, firstnumber=16]
private final LoginViewModel loginViewModel;

/**
 * Instantiates a new Login view model test.
 */
public LoginViewModelTest() {
    var clientFactory = new ClientFactory();
    var modelFactory = new ModelFactory(clientFactory);
    var viewModelFactory = new ViewModelFactory(modelFactory);
    loginViewModel = viewModelFactory.getLoginViewModel();
}
\end{code}

Herefter bliver setUp metoden kørt før hver test.\\

\begin{code}[caption=LoginViewModel.java, firstnumber=28]
@BeforeEach
void setUp() {
    loginViewModel.emailProperty().setValue("string@string.dk");
    loginViewModel.passwordProperty().setValue("string");
}
\end{code}

Her bliver loginViewModels email samt password sat.
Der er i alt fire test metoder, emailProperty, passwordProperty, loginResultProperty og clearFields.\\
    
\textbf{MailProperty} test metoden checker om den email fra setUp metoden er den samme som den forventede værdi.\\


\begin{code}[caption=LoginViewModel.java, firstnumber=34]
@Test
void emailProperty() {
    assertEquals("string@string.dk", loginViewModel.emailProperty().get());
}
\end{code}

Det sker ved at kalde assertEquals metoden der tjekker om den forventede værdi er lig den givende værdi. I dette tilfælde tjekker den om emailen er \textbf{string@string.dk} og hvis den ikke er fejler testen.\\
    
\textbf{PasswordProperty} test metoden gør det samme som emailProperty test metoden, men i stedet for en email er det et password der bliver testet for.\\
\begin{code}[caption=LoginViewModel.java, firstnumber=39]
@Test
void passwordProperty() {
    assertEquals("string", loginViewModel.passwordProperty().get());
}
\end{code}
    
\textbf{LoginResultProperty} test metoden bruger assertNull metoden, der fejler testen hvis det input den får er det samme som null. Her bliver loginViewModellens loginResponseProperty kaldt, for at se om den kan logge ind med de oplysninger som blev defineret ved setUp metoden. Så hvis den ikke kunne logge brugeren ind med de oplysninger den fik, returnerer den null og testen fejler.\\

\begin{code}[caption=LoginViewModel.java, firstnumber=44]
@Test
void loginResultProperty() {
    assertNull(loginViewModel.loginResponseProperty().get());
}
\end{code}
    
\textbf{ClearFields} test metoden kører først loginViewModel’s clearFields metode, der fjerner tekst i email og passwordProperty. Herefter tjekker den med assertEqueals om de to er tomme, ved at sammenligne dem med et empty string. Så hvis email og password felterne er tomme består testen.\\

\begin{code}[caption=LoginViewModel.java, firstnumber=49]
@Test
void clearFields() {
    loginViewModel.clearFields();
    assertEquals("", loginViewModel.emailProperty().get());
    assertEquals("", loginViewModel.passwordProperty().get());
}
\end{code}

\subsection{2. Iteration af desktop-klient testning}
Der er vil ingen grund til at skrive flere tests?
- Hvad tænker du, Simon?

Hello... it's me... I was wondering if after all these minutes you'd like to write 